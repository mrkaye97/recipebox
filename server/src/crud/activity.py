# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.28.0
# source: activity.sql
import datetime
import uuid
from collections.abc import AsyncIterator
from typing import Any

import pydantic
import sqlalchemy
import sqlalchemy.ext.asyncio

from src.crud import models

LIST_RECENT_RECIPE_COOKS = """-- name: list_recent_recipe_cooks \\:many
WITH recipes_cooked AS (
    SELECT user_id, recipe_id, cooked_at
    FROM recipe_cooking_log
    WHERE user_id = ANY(:p1\\:\\:UUID[])
    ORDER BY cooked_at DESC
    LIMIT :p3\\:\\:INT
    OFFSET :p2\\:\\:INT
)

SELECT
    r.id, r.user_id, r.name, r.author, r.cuisine, r.location, r.time_estimate_minutes, r.notes, r.last_made_at, r.created_at, r.updated_at,
    rc.cooked_at,
    u.name AS user_name
FROM recipes_cooked rc
JOIN recipe r ON r.id = rc.recipe_id
JOIN "user" u ON (u.id = r.user_id)
ORDER BY rc.cooked_at DESC
"""


class ListRecentRecipeCooksRow(pydantic.BaseModel):
    id: uuid.UUID
    user_id: uuid.UUID
    name: str
    author: str
    cuisine: str
    location: Any
    time_estimate_minutes: int
    notes: str | None
    last_made_at: datetime.datetime | None
    created_at: datetime.datetime
    updated_at: datetime.datetime
    cooked_at: datetime.datetime
    user_name: str


MARK_RECIPE_COOKED = """-- name: mark_recipe_cooked \\:one
WITH new_log AS (
    INSERT INTO recipe_cooking_log (recipe_id, user_id, cooked_at)
    VALUES (
        :p1\\:\\:UUID,
        :p2\\:\\:UUID,
        NOW()
    )
    RETURNING user_id, recipe_id, cooked_at
)

UPDATE recipe
SET
    last_made_at = (SELECT cooked_at FROM new_log),
    updated_at = CURRENT_TIMESTAMP
WHERE
    id = :p1\\:\\:UUID
    AND user_id = :p2\\:\\:UUID
RETURNING id, user_id, name, author, cuisine, location, time_estimate_minutes, notes, last_made_at, created_at, updated_at
"""


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def list_recent_recipe_cooks(
        self, *, userids: list[uuid.UUID], recentcooksoffset: int, recentcookslimit: int
    ) -> AsyncIterator[ListRecentRecipeCooksRow]:
        result = await self._conn.stream(
            sqlalchemy.text(LIST_RECENT_RECIPE_COOKS),
            {"p1": userids, "p2": recentcooksoffset, "p3": recentcookslimit},
        )
        async for row in result:
            yield ListRecentRecipeCooksRow(
                id=row[0],
                user_id=row[1],
                name=row[2],
                author=row[3],
                cuisine=row[4],
                location=row[5],
                time_estimate_minutes=row[6],
                notes=row[7],
                last_made_at=row[8],
                created_at=row[9],
                updated_at=row[10],
                cooked_at=row[11],
                user_name=row[12],
            )

    async def mark_recipe_cooked(
        self, *, recipeid: uuid.UUID, userid: uuid.UUID
    ) -> models.Recipe | None:
        row = (
            await self._conn.execute(
                sqlalchemy.text(MARK_RECIPE_COOKED), {"p1": recipeid, "p2": userid}
            )
        ).first()
        if row is None:
            return None
        return models.Recipe(
            id=row[0],
            user_id=row[1],
            name=row[2],
            author=row[3],
            cuisine=row[4],
            location=row[5],
            time_estimate_minutes=row[6],
            notes=row[7],
            last_made_at=row[8],
            created_at=row[9],
            updated_at=row[10],
        )
