# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.28.0
# source: recipes.sql
import uuid
from collections.abc import AsyncIterator
from typing import Any

import pydantic
import sqlalchemy
import sqlalchemy.ext.asyncio

from src.crud import models

CREATE_RECIPE = """-- name: create_recipe \\:one
INSERT INTO recipe (
    user_id,
    name,
    author,
    cuisine,
    location,
    time_estimate_minutes,
    notes,
    type,
    meal
)
VALUES (
    :p1\\:\\:UUID,
    :p2\\:\\:TEXT,
    :p3\\:\\:TEXT,
    :p4\\:\\:TEXT,
    :p5\\:\\:JSONB,
    :p6\\:\\:INTEGER,
    :p7\\:\\:TEXT,
    :p8\\:\\:recipe_type,
    :p9\\:\\:meal
)
RETURNING id, user_id, name, author, cuisine, location, time_estimate_minutes, notes, last_made_at, created_at, updated_at, type, meal
"""


class CreateRecipeParams(pydantic.BaseModel):
    userid: uuid.UUID
    name: str
    author: str
    cuisine: str
    location: Any
    timeestimateminutes: int
    notes: str | None
    type: models.RecipeType
    meal: models.Meal


CREATE_RECIPE_DIETARY_RESTRICTIONS_MET = """-- name: create_recipe_dietary_restrictions_met \\:many
WITH restrictions AS (
    SELECT UNNEST(:p3\\:\\:dietary_restriction[]) AS dietary_restriction
)

INSERT INTO recipe_dietary_restriction_met (recipe_id, user_id, dietary_restriction)
SELECT
    :p1\\:\\:UUID,
    :p2\\:\\:UUID,
    dietary_restriction
FROM restrictions
ON CONFLICT DO NOTHING
RETURNING id, user_id, recipe_id, dietary_restriction
"""


CREATE_RECIPE_INGREDIENTS = """-- name: create_recipe_ingredients \\:many
WITH ingredients AS (
    SELECT
        UNNEST(:p3\\:\\:TEXT[]) AS name,
        UNNEST(:p4\\:\\:FLOAT8[]) AS quantity,
        UNNEST(:p5\\:\\:TEXT[]) AS units
)

INSERT INTO recipe_ingredient (recipe_id, user_id, name, quantity, units)
SELECT
    :p1\\:\\:UUID,
    :p2\\:\\:UUID,
    name,
    quantity,
    units
FROM ingredients
ON CONFLICT DO NOTHING
RETURNING id, recipe_id, user_id, name, quantity, units, created_at, updated_at
"""


class CreateRecipeIngredientsParams(pydantic.BaseModel):
    recipeid: uuid.UUID
    userid: uuid.UUID
    names: list[str]
    quantities: list[float]
    units: list[str]


CREATE_RECIPE_INSTRUCTIONS = """-- name: create_recipe_instructions \\:many
WITH instructions AS (
    SELECT
        UNNEST(:p3\\:\\:INT[]) AS step_number,
        UNNEST(:p4\\:\\:TEXT[]) AS content
)

INSERT INTO recipe_instruction (recipe_id, user_id, step_number, content)
SELECT
    :p1\\:\\:UUID,
    :p2\\:\\:UUID,
    step_number,
    content
FROM instructions
ON CONFLICT DO NOTHING
RETURNING id, recipe_id, user_id, step_number, content, created_at, updated_at
"""


CREATE_RECIPE_TAGS = """-- name: create_recipe_tags \\:many
WITH tags AS (
    SELECT UNNEST(:p3\\:\\:TEXT[]) AS tag
)

INSERT INTO recipe_tag (recipe_id, user_id, tag)
SELECT
    :p1\\:\\:UUID,
    :p2\\:\\:UUID,
    tag
FROM tags
ON CONFLICT DO NOTHING
RETURNING id, user_id, recipe_id, tag
"""


DELETE_RECIPE = """-- name: delete_recipe \\:exec
DELETE FROM recipe
WHERE
    id = :p1\\:\\:UUID
    AND user_id = :p2\\:\\:UUID
RETURNING id, user_id, name, author, cuisine, location, time_estimate_minutes, notes, last_made_at, created_at, updated_at, type, meal
"""


DELETE_RECIPE_DIETARY_RESTRICTIONS_MET_BY_RECIPE_ID = """-- name: delete_recipe_dietary_restrictions_met_by_recipe_id \\:exec
DELETE FROM recipe_dietary_restriction_met
WHERE
    recipe_id = :p1\\:\\:UUID
    AND user_id = :p2\\:\\:UUID
"""


DELETE_RECIPE_INGREDIENTS_BY_RECIPE_ID = """-- name: delete_recipe_ingredients_by_recipe_id \\:exec
DELETE FROM recipe_ingredient
WHERE
    recipe_id = :p1\\:\\:UUID
    AND user_id = :p2\\:\\:UUID
"""


DELETE_RECIPE_INSTRUCTIONS_BY_RECIPE_ID = """-- name: delete_recipe_instructions_by_recipe_id \\:exec
DELETE FROM recipe_instruction
WHERE
    recipe_id = :p1\\:\\:UUID
    AND user_id = :p2\\:\\:UUID
"""


DELETE_RECIPE_TAGS_BY_RECIPE_ID = """-- name: delete_recipe_tags_by_recipe_id \\:exec
DELETE FROM recipe_tag
WHERE
    recipe_id = :p1\\:\\:UUID
    AND user_id = :p2\\:\\:UUID
"""


GET_RECIPE = """-- name: get_recipe \\:one
SELECT id, user_id, name, author, cuisine, location, time_estimate_minutes, notes, last_made_at, created_at, updated_at, type, meal
FROM recipe
WHERE id = :p1\\:\\:UUID
AND user_id = :p2\\:\\:UUID
"""


LIST_RECIPE_DIETARY_RESTRICTIONS_MET = """-- name: list_recipe_dietary_restrictions_met \\:many
SELECT id, user_id, recipe_id, dietary_restriction
FROM recipe_dietary_restriction_met
WHERE
    recipe_id = ANY(:p1\\:\\:UUID[])
    AND user_id = :p2\\:\\:UUID
"""


LIST_RECIPE_FILTER_OPTIONS = """-- name: list_recipe_filter_options \\:one
SELECT
    ARRAY_AGG(DISTINCT meal)\\:\\:meal[] AS meals,
    ARRAY_AGG(DISTINCT type)\\:\\:recipe_type[] AS types,
    ARRAY_AGG(DISTINCT cuisine)\\:\\:TEXT[] AS cuisines
FROM recipe
WHERE user_id = :p1\\:\\:UUID
"""


class ListRecipeFilterOptionsRow(pydantic.BaseModel):
    meals: list[models.Meal]
    types: list[models.RecipeType]
    cuisines: list[str]


LIST_RECIPE_INGREDIENTS = """-- name: list_recipe_ingredients \\:many
SELECT id, recipe_id, user_id, name, quantity, units, created_at, updated_at
FROM recipe_ingredient
WHERE
    recipe_id = ANY(:p1\\:\\:UUID[])
    AND user_id = :p2\\:\\:UUID
"""


LIST_RECIPE_INSTRUCTIONS = """-- name: list_recipe_instructions \\:many
SELECT id, recipe_id, user_id, step_number, content, created_at, updated_at
FROM recipe_instruction
WHERE
    recipe_id = ANY(:p1\\:\\:UUID[])
    AND user_id = :p2\\:\\:UUID
ORDER BY step_number ASC
"""


LIST_RECIPE_TAGS = """-- name: list_recipe_tags \\:many
SELECT id, user_id, recipe_id, tag
FROM recipe_tag
WHERE
    recipe_id = ANY(:p1\\:\\:UUID[])
    AND user_id = :p2\\:\\:UUID
"""


LIST_RECIPES = """-- name: list_recipes \\:many
SELECT id, user_id, name, author, cuisine, location, time_estimate_minutes, notes, last_made_at, created_at, updated_at, type, meal
FROM recipe
WHERE
    user_id = :p1\\:\\:UUID
    AND (
        :p2\\:\\:TEXT IS NULL
        OR id @@@ paradedb.parse(:p2\\:\\:TEXT, lenient => true)
    )
ORDER BY updated_at DESC
"""


LOG_RECIPE_RECOMMENDATION = """-- name: log_recipe_recommendation \\:exec
INSERT INTO recipe_recommendation (recipe_id, user_id)
VALUES (
    :p1\\:\\:UUID,
    :p2\\:\\:UUID
)
"""


RECOMMEND_RECIPE = """-- name: recommend_recipe \\:one
WITH ingredient_seasonality_score AS (
    SELECT
        recipe_id,
        user_id,
        SUM(paradedb.score(id)) as total_ingredient_score
    FROM recipe_ingredient
    WHERE
        id @@@ paradedb.parse(:p1\\:\\:TEXT, lenient => true)
        AND user_id = :p2\\:\\:UUID
    GROUP BY recipe_id, user_id
), last_recommended_at_score AS (
    SELECT
        recipe_id,
        user_id,
        GREATEST(1.0, LEAST(3.0, (NOW()\\:\\:DATE - COALESCE(MAX(rr.created_at)\\:\\:DATE, '1970-01-01'\\:\\:DATE)) / 30.0)) AS last_recommended_at_factor
    FROM recipe_recommendation rr
    WHERE rr.user_id = :p2\\:\\:UUID
    GROUP BY recipe_id, user_id
), candidates AS (
    SELECT r.id
    FROM recipe r
    LEFT JOIN ingredient_seasonality_score iss ON (r.id, r.user_id) = (iss.recipe_id, iss.user_id)
    LEFT JOIN last_recommended_at_score lras ON (r.id, r.user_id) = (lras.recipe_id, lras.user_id)
    WHERE r.user_id = :p2\\:\\:UUID
    ORDER BY (
        CASE
            WHEN EXTRACT(ISODOW FROM NOW()\\:\\:DATE) IN (6, 7) AND r.time_estimate_minutes > 60 THEN 0.5
            ELSE 1.0
        END *
        CASE
            WHEN r.last_made_at IS NULL THEN 1.0
            ELSE GREATEST(1.0, LEAST(3.0, (NOW()\\:\\:DATE - r.last_made_at\\:\\:DATE) / 30.0))
        END *
        COALESCE(lras.last_recommended_at_factor, 1.0) *
        COALESCE(iss.total_ingredient_score + 1.0, 1.0)
    ) DESC
    LIMIT 10
)

SELECT id, user_id, name, author, cuisine, location, time_estimate_minutes, notes, last_made_at, created_at, updated_at, type, meal
FROM recipe
WHERE id IN (
    SELECT id
    FROM candidates
)
ORDER BY RANDOM()
LIMIT 1
"""


UPDATE_RECIPE = """-- name: update_recipe \\:one
UPDATE recipe
SET
    name = COALESCE(:p1\\:\\:TEXT, name),
    author = COALESCE(:p2\\:\\:TEXT, author),
    cuisine = COALESCE(:p3\\:\\:TEXT, cuisine),
    location = COALESCE(:p4\\:\\:JSONB, location),
    time_estimate_minutes = COALESCE(:p5\\:\\:INT, time_estimate_minutes),
    notes = COALESCE(:p6\\:\\:TEXT, notes),
    meal = COALESCE(:p7\\:\\:meal, meal),
    type = COALESCE(:p8\\:\\:recipe_type, type),
    updated_at = CURRENT_TIMESTAMP
WHERE
    id = :p9\\:\\:UUID
    AND user_id = :p10\\:\\:UUID
RETURNING id, user_id, name, author, cuisine, location, time_estimate_minutes, notes, last_made_at, created_at, updated_at, type, meal
"""


class UpdateRecipeParams(pydantic.BaseModel):
    name: str | None
    author: str | None
    cuisine: str | None
    location: Any | None
    time_estimate_minutes: int | None
    notes: str | None
    meal: models.Meal | None
    type: models.RecipeType | None
    recipeid: uuid.UUID
    userid: uuid.UUID


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def create_recipe(self, arg: CreateRecipeParams) -> models.Recipe | None:
        row = (
            await self._conn.execute(
                sqlalchemy.text(CREATE_RECIPE),
                {
                    "p1": arg.userid,
                    "p2": arg.name,
                    "p3": arg.author,
                    "p4": arg.cuisine,
                    "p5": arg.location,
                    "p6": arg.timeestimateminutes,
                    "p7": arg.notes,
                    "p8": arg.type,
                    "p9": arg.meal,
                },
            )
        ).first()
        if row is None:
            return None
        return models.Recipe(
            id=row[0],
            user_id=row[1],
            name=row[2],
            author=row[3],
            cuisine=row[4],
            location=row[5],
            time_estimate_minutes=row[6],
            notes=row[7],
            last_made_at=row[8],
            created_at=row[9],
            updated_at=row[10],
            type=row[11],
            meal=row[12],
        )

    async def create_recipe_dietary_restrictions_met(
        self,
        *,
        recipeid: uuid.UUID,
        userid: uuid.UUID,
        dietaryrestrictionsmets: list[models.DietaryRestriction],
    ) -> AsyncIterator[models.RecipeDietaryRestrictionMet]:
        result = await self._conn.stream(
            sqlalchemy.text(CREATE_RECIPE_DIETARY_RESTRICTIONS_MET),
            {"p1": recipeid, "p2": userid, "p3": dietaryrestrictionsmets},
        )
        async for row in result:
            yield models.RecipeDietaryRestrictionMet(
                id=row[0],
                user_id=row[1],
                recipe_id=row[2],
                dietary_restriction=row[3],
            )

    async def create_recipe_ingredients(
        self, arg: CreateRecipeIngredientsParams
    ) -> AsyncIterator[models.RecipeIngredient]:
        result = await self._conn.stream(
            sqlalchemy.text(CREATE_RECIPE_INGREDIENTS),
            {
                "p1": arg.recipeid,
                "p2": arg.userid,
                "p3": arg.names,
                "p4": arg.quantities,
                "p5": arg.units,
            },
        )
        async for row in result:
            yield models.RecipeIngredient(
                id=row[0],
                recipe_id=row[1],
                user_id=row[2],
                name=row[3],
                quantity=row[4],
                units=row[5],
                created_at=row[6],
                updated_at=row[7],
            )

    async def create_recipe_instructions(
        self,
        *,
        recipeid: uuid.UUID,
        userid: uuid.UUID,
        stepnumbers: list[int],
        contents: list[str],
    ) -> AsyncIterator[models.RecipeInstruction]:
        result = await self._conn.stream(
            sqlalchemy.text(CREATE_RECIPE_INSTRUCTIONS),
            {
                "p1": recipeid,
                "p2": userid,
                "p3": stepnumbers,
                "p4": contents,
            },
        )
        async for row in result:
            yield models.RecipeInstruction(
                id=row[0],
                recipe_id=row[1],
                user_id=row[2],
                step_number=row[3],
                content=row[4],
                created_at=row[5],
                updated_at=row[6],
            )

    async def create_recipe_tags(
        self, *, recipeid: uuid.UUID, userid: uuid.UUID, tags: list[str]
    ) -> AsyncIterator[models.RecipeTag]:
        result = await self._conn.stream(
            sqlalchemy.text(CREATE_RECIPE_TAGS),
            {"p1": recipeid, "p2": userid, "p3": tags},
        )
        async for row in result:
            yield models.RecipeTag(
                id=row[0],
                user_id=row[1],
                recipe_id=row[2],
                tag=row[3],
            )

    async def delete_recipe(self, *, recipeid: uuid.UUID, userid: uuid.UUID) -> None:
        await self._conn.execute(
            sqlalchemy.text(DELETE_RECIPE), {"p1": recipeid, "p2": userid}
        )

    async def delete_recipe_dietary_restrictions_met_by_recipe_id(
        self, *, recipeid: uuid.UUID, userid: uuid.UUID
    ) -> None:
        await self._conn.execute(
            sqlalchemy.text(DELETE_RECIPE_DIETARY_RESTRICTIONS_MET_BY_RECIPE_ID),
            {"p1": recipeid, "p2": userid},
        )

    async def delete_recipe_ingredients_by_recipe_id(
        self, *, recipeid: uuid.UUID, userid: uuid.UUID
    ) -> None:
        await self._conn.execute(
            sqlalchemy.text(DELETE_RECIPE_INGREDIENTS_BY_RECIPE_ID),
            {"p1": recipeid, "p2": userid},
        )

    async def delete_recipe_instructions_by_recipe_id(
        self, *, recipeid: uuid.UUID, userid: uuid.UUID
    ) -> None:
        await self._conn.execute(
            sqlalchemy.text(DELETE_RECIPE_INSTRUCTIONS_BY_RECIPE_ID),
            {"p1": recipeid, "p2": userid},
        )

    async def delete_recipe_tags_by_recipe_id(
        self, *, recipeid: uuid.UUID, userid: uuid.UUID
    ) -> None:
        await self._conn.execute(
            sqlalchemy.text(DELETE_RECIPE_TAGS_BY_RECIPE_ID),
            {"p1": recipeid, "p2": userid},
        )

    async def get_recipe(
        self, *, recipeid: uuid.UUID, userid: uuid.UUID
    ) -> models.Recipe | None:
        row = (
            await self._conn.execute(
                sqlalchemy.text(GET_RECIPE), {"p1": recipeid, "p2": userid}
            )
        ).first()
        if row is None:
            return None
        return models.Recipe(
            id=row[0],
            user_id=row[1],
            name=row[2],
            author=row[3],
            cuisine=row[4],
            location=row[5],
            time_estimate_minutes=row[6],
            notes=row[7],
            last_made_at=row[8],
            created_at=row[9],
            updated_at=row[10],
            type=row[11],
            meal=row[12],
        )

    async def list_recipe_dietary_restrictions_met(
        self, *, recipeids: list[uuid.UUID], userid: uuid.UUID
    ) -> AsyncIterator[models.RecipeDietaryRestrictionMet]:
        result = await self._conn.stream(
            sqlalchemy.text(LIST_RECIPE_DIETARY_RESTRICTIONS_MET),
            {"p1": recipeids, "p2": userid},
        )
        async for row in result:
            yield models.RecipeDietaryRestrictionMet(
                id=row[0],
                user_id=row[1],
                recipe_id=row[2],
                dietary_restriction=row[3],
            )

    async def list_recipe_filter_options(
        self, *, userid: uuid.UUID
    ) -> ListRecipeFilterOptionsRow | None:
        row = (
            await self._conn.execute(
                sqlalchemy.text(LIST_RECIPE_FILTER_OPTIONS), {"p1": userid}
            )
        ).first()
        if row is None:
            return None
        return ListRecipeFilterOptionsRow(
            meals=row[0],
            types=row[1],
            cuisines=row[2],
        )

    async def list_recipe_ingredients(
        self, *, recipeids: list[uuid.UUID], userid: uuid.UUID
    ) -> AsyncIterator[models.RecipeIngredient]:
        result = await self._conn.stream(
            sqlalchemy.text(LIST_RECIPE_INGREDIENTS), {"p1": recipeids, "p2": userid}
        )
        async for row in result:
            yield models.RecipeIngredient(
                id=row[0],
                recipe_id=row[1],
                user_id=row[2],
                name=row[3],
                quantity=row[4],
                units=row[5],
                created_at=row[6],
                updated_at=row[7],
            )

    async def list_recipe_instructions(
        self, *, recipeids: list[uuid.UUID], userid: uuid.UUID
    ) -> AsyncIterator[models.RecipeInstruction]:
        result = await self._conn.stream(
            sqlalchemy.text(LIST_RECIPE_INSTRUCTIONS), {"p1": recipeids, "p2": userid}
        )
        async for row in result:
            yield models.RecipeInstruction(
                id=row[0],
                recipe_id=row[1],
                user_id=row[2],
                step_number=row[3],
                content=row[4],
                created_at=row[5],
                updated_at=row[6],
            )

    async def list_recipe_tags(
        self, *, recipeids: list[uuid.UUID], userid: uuid.UUID
    ) -> AsyncIterator[models.RecipeTag]:
        result = await self._conn.stream(
            sqlalchemy.text(LIST_RECIPE_TAGS), {"p1": recipeids, "p2": userid}
        )
        async for row in result:
            yield models.RecipeTag(
                id=row[0],
                user_id=row[1],
                recipe_id=row[2],
                tag=row[3],
            )

    async def list_recipes(
        self, *, userid: uuid.UUID, search: str | None
    ) -> AsyncIterator[models.Recipe]:
        result = await self._conn.stream(
            sqlalchemy.text(LIST_RECIPES), {"p1": userid, "p2": search}
        )
        async for row in result:
            yield models.Recipe(
                id=row[0],
                user_id=row[1],
                name=row[2],
                author=row[3],
                cuisine=row[4],
                location=row[5],
                time_estimate_minutes=row[6],
                notes=row[7],
                last_made_at=row[8],
                created_at=row[9],
                updated_at=row[10],
                type=row[11],
                meal=row[12],
            )

    async def log_recipe_recommendation(
        self, *, recipeid: uuid.UUID, userid: uuid.UUID
    ) -> None:
        await self._conn.execute(
            sqlalchemy.text(LOG_RECIPE_RECOMMENDATION), {"p1": recipeid, "p2": userid}
        )

    async def recommend_recipe(
        self, *, seasonalingredients: str, userid: uuid.UUID
    ) -> models.Recipe | None:
        row = (
            await self._conn.execute(
                sqlalchemy.text(RECOMMEND_RECIPE),
                {"p1": seasonalingredients, "p2": userid},
            )
        ).first()
        if row is None:
            return None
        return models.Recipe(
            id=row[0],
            user_id=row[1],
            name=row[2],
            author=row[3],
            cuisine=row[4],
            location=row[5],
            time_estimate_minutes=row[6],
            notes=row[7],
            last_made_at=row[8],
            created_at=row[9],
            updated_at=row[10],
            type=row[11],
            meal=row[12],
        )

    async def update_recipe(self, arg: UpdateRecipeParams) -> models.Recipe | None:
        row = (
            await self._conn.execute(
                sqlalchemy.text(UPDATE_RECIPE),
                {
                    "p1": arg.name,
                    "p2": arg.author,
                    "p3": arg.cuisine,
                    "p4": arg.location,
                    "p5": arg.time_estimate_minutes,
                    "p6": arg.notes,
                    "p7": arg.meal,
                    "p8": arg.type,
                    "p9": arg.recipeid,
                    "p10": arg.userid,
                },
            )
        ).first()
        if row is None:
            return None
        return models.Recipe(
            id=row[0],
            user_id=row[1],
            name=row[2],
            author=row[3],
            cuisine=row[4],
            location=row[5],
            time_estimate_minutes=row[6],
            notes=row[7],
            last_made_at=row[8],
            created_at=row[9],
            updated_at=row[10],
            type=row[11],
            meal=row[12],
        )
