# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.28.0
# source: recipes.sql
import uuid
from collections.abc import AsyncIterator
from typing import Any

import pydantic
import sqlalchemy
import sqlalchemy.ext.asyncio

from src.crud import models

CREATE_RECIPE = """-- name: create_recipe \\:one
INSERT INTO recipe (
    user_id,
    name,
    author,
    cuisine,
    location,
    time_estimate_minutes,
    notes,
    type,
    meal,
    parent_recipe_id
)
VALUES (
    :p1\\:\\:UUID,
    :p2\\:\\:TEXT,
    :p3\\:\\:TEXT,
    :p4\\:\\:TEXT,
    :p5\\:\\:JSONB,
    :p6\\:\\:INTEGER,
    :p7\\:\\:TEXT,
    :p8\\:\\:recipe_type,
    :p9\\:\\:meal,
    :p10\\:\\:UUID
)
RETURNING id, user_id, name, author, cuisine, location, time_estimate_minutes, notes, last_made_at, created_at, updated_at, type, meal, parent_recipe_id
"""


class CreateRecipeParams(pydantic.BaseModel):
    userid: uuid.UUID
    name: str
    author: str
    cuisine: str
    location: Any
    timeestimateminutes: int
    notes: str | None
    type: models.RecipeType
    meal: models.Meal
    parent_recipe_id: uuid.UUID | None


CREATE_RECIPE_DIETARY_RESTRICTIONS_MET = """-- name: create_recipe_dietary_restrictions_met \\:many
WITH restrictions AS (
    SELECT UNNEST(:p2\\:\\:dietary_restriction[]) AS dietary_restriction
)

INSERT INTO recipe_dietary_restriction_met (recipe_id, dietary_restriction)
SELECT
    :p1\\:\\:UUID,
    dietary_restriction
FROM restrictions
ON CONFLICT DO NOTHING
RETURNING id, recipe_id, dietary_restriction
"""


CREATE_RECIPE_INGREDIENTS = """-- name: create_recipe_ingredients \\:many
WITH ingredients AS (
    SELECT
        UNNEST(:p2\\:\\:TEXT[]) AS name,
        UNNEST(:p3\\:\\:FLOAT8[]) AS quantity,
        UNNEST(:p4\\:\\:TEXT[]) AS units
)

INSERT INTO recipe_ingredient (recipe_id, name, quantity, units)
SELECT
    :p1\\:\\:UUID,
    name,
    quantity,
    units
FROM ingredients
ON CONFLICT DO NOTHING
RETURNING id, recipe_id, name, quantity, units, created_at, updated_at
"""


CREATE_RECIPE_INSTRUCTIONS = """-- name: create_recipe_instructions \\:many
WITH instructions AS (
    SELECT
        UNNEST(:p2\\:\\:INT[]) AS step_number,
        UNNEST(:p3\\:\\:TEXT[]) AS content
)

INSERT INTO recipe_instruction (recipe_id, step_number, content)
SELECT
    :p1\\:\\:UUID,
    step_number,
    content
FROM instructions
ON CONFLICT DO NOTHING
RETURNING id, recipe_id, step_number, content, created_at, updated_at
"""


CREATE_RECIPE_TAGS = """-- name: create_recipe_tags \\:many
WITH tags AS (
    SELECT UNNEST(:p2\\:\\:TEXT[]) AS tag
)

INSERT INTO recipe_tag (recipe_id, tag)
SELECT
    :p1\\:\\:UUID,
    tag
FROM tags
ON CONFLICT DO NOTHING
RETURNING id, recipe_id, tag
"""


DELETE_RECIPE = """-- name: delete_recipe \\:exec
DELETE FROM recipe
WHERE id = :p1\\:\\:UUID
RETURNING id, user_id, name, author, cuisine, location, time_estimate_minutes, notes, last_made_at, created_at, updated_at, type, meal, parent_recipe_id
"""


DELETE_RECIPE_DIETARY_RESTRICTIONS_MET_BY_RECIPE_ID = """-- name: delete_recipe_dietary_restrictions_met_by_recipe_id \\:exec
DELETE FROM recipe_dietary_restriction_met
WHERE recipe_id = :p1\\:\\:UUID
"""


DELETE_RECIPE_INGREDIENTS_BY_RECIPE_ID = """-- name: delete_recipe_ingredients_by_recipe_id \\:exec
DELETE FROM recipe_ingredient
WHERE recipe_id = :p1\\:\\:UUID
"""


DELETE_RECIPE_INSTRUCTIONS_BY_RECIPE_ID = """-- name: delete_recipe_instructions_by_recipe_id \\:exec
DELETE FROM recipe_instruction
WHERE recipe_id = :p1\\:\\:UUID
"""


DELETE_RECIPE_TAGS_BY_RECIPE_ID = """-- name: delete_recipe_tags_by_recipe_id \\:exec
DELETE FROM recipe_tag
WHERE recipe_id = :p1\\:\\:UUID
"""


GET_RECIPE = """-- name: get_recipe \\:one
SELECT id, user_id, name, author, cuisine, location, time_estimate_minutes, notes, last_made_at, created_at, updated_at, type, meal, parent_recipe_id
FROM recipe
WHERE
    id = :p1\\:\\:UUID
"""


LIST_RECIPE_DIETARY_RESTRICTIONS_MET = """-- name: list_recipe_dietary_restrictions_met \\:many
SELECT id, recipe_id, dietary_restriction
FROM recipe_dietary_restriction_met
WHERE recipe_id = ANY(:p1\\:\\:UUID[])
"""


LIST_RECIPE_FILTER_OPTIONS = """-- name: list_recipe_filter_options \\:one
SELECT
    ARRAY_AGG(DISTINCT meal)\\:\\:meal[] AS meals,
    ARRAY_AGG(DISTINCT type)\\:\\:recipe_type[] AS types,
    ARRAY_AGG(DISTINCT cuisine)\\:\\:TEXT[] AS cuisines
FROM recipe
WHERE user_id = :p1\\:\\:UUID
"""


class ListRecipeFilterOptionsRow(pydantic.BaseModel):
    meals: list[models.Meal]
    types: list[models.RecipeType]
    cuisines: list[str]


LIST_RECIPE_INGREDIENTS = """-- name: list_recipe_ingredients \\:many
SELECT id, recipe_id, name, quantity, units, created_at, updated_at
FROM recipe_ingredient
WHERE recipe_id = ANY(:p1\\:\\:UUID[])
"""


LIST_RECIPE_INSTRUCTIONS = """-- name: list_recipe_instructions \\:many
SELECT id, recipe_id, step_number, content, created_at, updated_at
FROM recipe_instruction
WHERE recipe_id = ANY(:p1\\:\\:UUID[])
ORDER BY step_number ASC
"""


LIST_RECIPE_TAGS = """-- name: list_recipe_tags \\:many
SELECT id, recipe_id, tag
FROM recipe_tag
WHERE recipe_id = ANY(:p1\\:\\:UUID[])
"""


LIST_RECIPES = """-- name: list_recipes \\:many
SELECT r.id, r.user_id, r.name, r.author, r.cuisine, r.location, r.time_estimate_minutes, r.notes, r.last_made_at, r.created_at, r.updated_at, r.type, r.meal, r.parent_recipe_id
FROM recipe r
JOIN "user" u ON u.id = r.user_id
WHERE
    (
        (
            -- either we're getting a list of all recipes
            :p1\\:\\:BOOLEAN = FALSE
            -- only include recipes for users who have made their recipes public
            AND u.privacy_preference = 'public'
            -- don't include recipes where we already have that recipe as a parent
            -- since that means we've already downloaded that recipe
            AND r.parent_recipe_id NOT IN (
                SELECT id
                FROM recipe
                WHERE user_id = :p2\\:\\:UUID
            )
            AND r.user_id != :p2\\:\\:UUID
        )
        OR (
            :p1\\:\\:BOOLEAN
            AND r.user_id = :p2\\:\\:UUID
        )
    )
    AND (
        :p3\\:\\:TEXT IS NULL
        OR r.id @@@ paradedb.parse(:p3\\:\\:TEXT, lenient => true)
    )
ORDER BY r.updated_at DESC
"""


LOG_RECIPE_RECOMMENDATION = """-- name: log_recipe_recommendation \\:exec
INSERT INTO recipe_recommendation (recipe_id, user_id)
VALUES (
    :p1\\:\\:UUID,
    :p2\\:\\:UUID
)
"""


RECOMMEND_RECIPE = """-- name: recommend_recipe \\:one
WITH ingredient_seasonality_score AS (
    SELECT
        recipe_id,
        SUM(paradedb.score(i.id)) as total_ingredient_score
    FROM recipe r
    JOIN recipe_ingredient i ON r.id = i.recipe_id
    WHERE
        i.id @@@ paradedb.parse(:p1\\:\\:TEXT, lenient => true)
        AND r.user_id = :p2\\:\\:UUID
    GROUP BY i.recipe_id
), last_recommended_at_score AS (
    SELECT
        recipe_id,
        GREATEST(1.0, LEAST(3.0, (NOW()\\:\\:DATE - COALESCE(MAX(rr.created_at)\\:\\:DATE, '1970-01-01'\\:\\:DATE)) / 30.0)) AS last_recommended_at_factor
    FROM recipe_recommendation rr
    WHERE rr.user_id = :p2\\:\\:UUID
    GROUP BY recipe_id
), candidates AS (
    SELECT
        r.id,
        (
            CASE
                -- don't recommend long recipes on weekdays
                WHEN EXTRACT(ISODOW FROM NOW()\\:\\:DATE) IN (1, 2, 3, 4, 5) AND r.time_estimate_minutes > 90 THEN 0.0
                WHEN EXTRACT(ISODOW FROM NOW()\\:\\:DATE) IN (1, 2, 3, 4, 5) AND r.time_estimate_minutes > 60 THEN 0.2
                ELSE 1.0
            END *
            CASE
                WHEN r.last_made_at IS NULL THEN 1.0
                ELSE GREATEST(1.0, LEAST(3.0, (NOW()\\:\\:DATE - r.last_made_at\\:\\:DATE) / 30.0))
            END *
            COALESCE(lras.last_recommended_at_factor, 1.0) *
            COALESCE(iss.total_ingredient_score + 1.0, 1.0)
        ) AS score
    FROM recipe r
    LEFT JOIN ingredient_seasonality_score iss ON r.id = iss.recipe_id
    LEFT JOIN last_recommended_at_score lras ON r.id = lras.recipe_id
    WHERE r.user_id = :p2\\:\\:UUID
    ORDER BY (
        CASE
            WHEN EXTRACT(ISODOW FROM NOW()\\:\\:DATE) IN (6, 7) AND r.time_estimate_minutes > 60 THEN 0.5
            ELSE 1.0
        END *
        CASE
            WHEN r.last_made_at IS NULL THEN 1.0
            ELSE GREATEST(1.0, LEAST(3.0, (NOW()\\:\\:DATE - r.last_made_at\\:\\:DATE) / 30.0))
        END *
        COALESCE(lras.last_recommended_at_factor, 1.0) *
        COALESCE(iss.total_ingredient_score + 1.0, 1.0)
    ) DESC
    LIMIT 15
), weights AS (
    SELECT
        id,
        score / SUM(score) OVER () AS weight
    FROM candidates
), cumulative_weights AS (
    SELECT
        id,
        weight,
        SUM(weight) OVER (ORDER BY id ROWS UNBOUNDED PRECEDING) AS cumulative_weight
    FROM weights
), random_threshold AS (
    SELECT RANDOM() AS threshold
)

SELECT r.id, r.user_id, r.name, r.author, r.cuisine, r.location, r.time_estimate_minutes, r.notes, r.last_made_at, r.created_at, r.updated_at, r.type, r.meal, r.parent_recipe_id
FROM recipe r
JOIN cumulative_weights cw ON r.id = cw.id
CROSS JOIN random_threshold rt
WHERE cw.cumulative_weight >= rt.threshold
ORDER BY cw.cumulative_weight
LIMIT 1
"""


UPDATE_RECIPE = """-- name: update_recipe \\:one
UPDATE recipe
SET
    name = COALESCE(:p1\\:\\:TEXT, name),
    author = COALESCE(:p2\\:\\:TEXT, author),
    cuisine = COALESCE(:p3\\:\\:TEXT, cuisine),
    location = COALESCE(:p4\\:\\:JSONB, location),
    time_estimate_minutes = COALESCE(:p5\\:\\:INT, time_estimate_minutes),
    notes = COALESCE(:p6\\:\\:TEXT, notes),
    meal = COALESCE(:p7\\:\\:meal, meal),
    type = COALESCE(:p8\\:\\:recipe_type, type),
    updated_at = CURRENT_TIMESTAMP
WHERE id = :p9\\:\\:UUID
RETURNING id, user_id, name, author, cuisine, location, time_estimate_minutes, notes, last_made_at, created_at, updated_at, type, meal, parent_recipe_id
"""


class UpdateRecipeParams(pydantic.BaseModel):
    name: str | None
    author: str | None
    cuisine: str | None
    location: Any | None
    time_estimate_minutes: int | None
    notes: str | None
    meal: models.Meal | None
    type: models.RecipeType | None
    recipeid: uuid.UUID


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def create_recipe(self, arg: CreateRecipeParams) -> models.Recipe | None:
        row = (
            await self._conn.execute(
                sqlalchemy.text(CREATE_RECIPE),
                {
                    "p1": arg.userid,
                    "p2": arg.name,
                    "p3": arg.author,
                    "p4": arg.cuisine,
                    "p5": arg.location,
                    "p6": arg.timeestimateminutes,
                    "p7": arg.notes,
                    "p8": arg.type,
                    "p9": arg.meal,
                    "p10": arg.parent_recipe_id,
                },
            )
        ).first()
        if row is None:
            return None
        return models.Recipe(
            id=row[0],
            user_id=row[1],
            name=row[2],
            author=row[3],
            cuisine=row[4],
            location=row[5],
            time_estimate_minutes=row[6],
            notes=row[7],
            last_made_at=row[8],
            created_at=row[9],
            updated_at=row[10],
            type=row[11],
            meal=row[12],
            parent_recipe_id=row[13],
        )

    async def create_recipe_dietary_restrictions_met(
        self,
        *,
        recipeid: uuid.UUID,
        dietaryrestrictionsmets: list[models.DietaryRestriction],
    ) -> AsyncIterator[models.RecipeDietaryRestrictionMet]:
        result = await self._conn.stream(
            sqlalchemy.text(CREATE_RECIPE_DIETARY_RESTRICTIONS_MET),
            {"p1": recipeid, "p2": dietaryrestrictionsmets},
        )
        async for row in result:
            yield models.RecipeDietaryRestrictionMet(
                id=row[0],
                recipe_id=row[1],
                dietary_restriction=row[2],
            )

    async def create_recipe_ingredients(
        self,
        *,
        recipeid: uuid.UUID,
        names: list[str],
        quantities: list[float],
        units: list[str],
    ) -> AsyncIterator[models.RecipeIngredient]:
        result = await self._conn.stream(
            sqlalchemy.text(CREATE_RECIPE_INGREDIENTS),
            {
                "p1": recipeid,
                "p2": names,
                "p3": quantities,
                "p4": units,
            },
        )
        async for row in result:
            yield models.RecipeIngredient(
                id=row[0],
                recipe_id=row[1],
                name=row[2],
                quantity=row[3],
                units=row[4],
                created_at=row[5],
                updated_at=row[6],
            )

    async def create_recipe_instructions(
        self, *, recipeid: uuid.UUID, stepnumbers: list[int], contents: list[str]
    ) -> AsyncIterator[models.RecipeInstruction]:
        result = await self._conn.stream(
            sqlalchemy.text(CREATE_RECIPE_INSTRUCTIONS),
            {"p1": recipeid, "p2": stepnumbers, "p3": contents},
        )
        async for row in result:
            yield models.RecipeInstruction(
                id=row[0],
                recipe_id=row[1],
                step_number=row[2],
                content=row[3],
                created_at=row[4],
                updated_at=row[5],
            )

    async def create_recipe_tags(
        self, *, recipeid: uuid.UUID, tags: list[str]
    ) -> AsyncIterator[models.RecipeTag]:
        result = await self._conn.stream(
            sqlalchemy.text(CREATE_RECIPE_TAGS), {"p1": recipeid, "p2": tags}
        )
        async for row in result:
            yield models.RecipeTag(
                id=row[0],
                recipe_id=row[1],
                tag=row[2],
            )

    async def delete_recipe(self, *, recipeid: uuid.UUID) -> None:
        await self._conn.execute(sqlalchemy.text(DELETE_RECIPE), {"p1": recipeid})

    async def delete_recipe_dietary_restrictions_met_by_recipe_id(
        self, *, recipeid: uuid.UUID
    ) -> None:
        await self._conn.execute(
            sqlalchemy.text(DELETE_RECIPE_DIETARY_RESTRICTIONS_MET_BY_RECIPE_ID),
            {"p1": recipeid},
        )

    async def delete_recipe_ingredients_by_recipe_id(
        self, *, recipeid: uuid.UUID
    ) -> None:
        await self._conn.execute(
            sqlalchemy.text(DELETE_RECIPE_INGREDIENTS_BY_RECIPE_ID), {"p1": recipeid}
        )

    async def delete_recipe_instructions_by_recipe_id(
        self, *, recipeid: uuid.UUID
    ) -> None:
        await self._conn.execute(
            sqlalchemy.text(DELETE_RECIPE_INSTRUCTIONS_BY_RECIPE_ID), {"p1": recipeid}
        )

    async def delete_recipe_tags_by_recipe_id(self, *, recipeid: uuid.UUID) -> None:
        await self._conn.execute(
            sqlalchemy.text(DELETE_RECIPE_TAGS_BY_RECIPE_ID), {"p1": recipeid}
        )

    async def get_recipe(self, *, recipeid: uuid.UUID) -> models.Recipe | None:
        row = (
            await self._conn.execute(sqlalchemy.text(GET_RECIPE), {"p1": recipeid})
        ).first()
        if row is None:
            return None
        return models.Recipe(
            id=row[0],
            user_id=row[1],
            name=row[2],
            author=row[3],
            cuisine=row[4],
            location=row[5],
            time_estimate_minutes=row[6],
            notes=row[7],
            last_made_at=row[8],
            created_at=row[9],
            updated_at=row[10],
            type=row[11],
            meal=row[12],
            parent_recipe_id=row[13],
        )

    async def list_recipe_dietary_restrictions_met(
        self, *, recipeids: list[uuid.UUID]
    ) -> AsyncIterator[models.RecipeDietaryRestrictionMet]:
        result = await self._conn.stream(
            sqlalchemy.text(LIST_RECIPE_DIETARY_RESTRICTIONS_MET), {"p1": recipeids}
        )
        async for row in result:
            yield models.RecipeDietaryRestrictionMet(
                id=row[0],
                recipe_id=row[1],
                dietary_restriction=row[2],
            )

    async def list_recipe_filter_options(
        self, *, userid: uuid.UUID
    ) -> ListRecipeFilterOptionsRow | None:
        row = (
            await self._conn.execute(
                sqlalchemy.text(LIST_RECIPE_FILTER_OPTIONS), {"p1": userid}
            )
        ).first()
        if row is None:
            return None
        return ListRecipeFilterOptionsRow(
            meals=row[0],
            types=row[1],
            cuisines=row[2],
        )

    async def list_recipe_ingredients(
        self, *, recipeids: list[uuid.UUID]
    ) -> AsyncIterator[models.RecipeIngredient]:
        result = await self._conn.stream(
            sqlalchemy.text(LIST_RECIPE_INGREDIENTS), {"p1": recipeids}
        )
        async for row in result:
            yield models.RecipeIngredient(
                id=row[0],
                recipe_id=row[1],
                name=row[2],
                quantity=row[3],
                units=row[4],
                created_at=row[5],
                updated_at=row[6],
            )

    async def list_recipe_instructions(
        self, *, recipeids: list[uuid.UUID]
    ) -> AsyncIterator[models.RecipeInstruction]:
        result = await self._conn.stream(
            sqlalchemy.text(LIST_RECIPE_INSTRUCTIONS), {"p1": recipeids}
        )
        async for row in result:
            yield models.RecipeInstruction(
                id=row[0],
                recipe_id=row[1],
                step_number=row[2],
                content=row[3],
                created_at=row[4],
                updated_at=row[5],
            )

    async def list_recipe_tags(
        self, *, recipeids: list[uuid.UUID]
    ) -> AsyncIterator[models.RecipeTag]:
        result = await self._conn.stream(
            sqlalchemy.text(LIST_RECIPE_TAGS), {"p1": recipeids}
        )
        async for row in result:
            yield models.RecipeTag(
                id=row[0],
                recipe_id=row[1],
                tag=row[2],
            )

    async def list_recipes(
        self, *, onlyuser: bool, userid: uuid.UUID, search: str | None
    ) -> AsyncIterator[models.Recipe]:
        result = await self._conn.stream(
            sqlalchemy.text(LIST_RECIPES), {"p1": onlyuser, "p2": userid, "p3": search}
        )
        async for row in result:
            yield models.Recipe(
                id=row[0],
                user_id=row[1],
                name=row[2],
                author=row[3],
                cuisine=row[4],
                location=row[5],
                time_estimate_minutes=row[6],
                notes=row[7],
                last_made_at=row[8],
                created_at=row[9],
                updated_at=row[10],
                type=row[11],
                meal=row[12],
                parent_recipe_id=row[13],
            )

    async def log_recipe_recommendation(
        self, *, recipeid: uuid.UUID, userid: uuid.UUID
    ) -> None:
        await self._conn.execute(
            sqlalchemy.text(LOG_RECIPE_RECOMMENDATION), {"p1": recipeid, "p2": userid}
        )

    async def recommend_recipe(
        self, *, seasonalingredients: str, userid: uuid.UUID
    ) -> models.Recipe | None:
        row = (
            await self._conn.execute(
                sqlalchemy.text(RECOMMEND_RECIPE),
                {"p1": seasonalingredients, "p2": userid},
            )
        ).first()
        if row is None:
            return None
        return models.Recipe(
            id=row[0],
            user_id=row[1],
            name=row[2],
            author=row[3],
            cuisine=row[4],
            location=row[5],
            time_estimate_minutes=row[6],
            notes=row[7],
            last_made_at=row[8],
            created_at=row[9],
            updated_at=row[10],
            type=row[11],
            meal=row[12],
            parent_recipe_id=row[13],
        )

    async def update_recipe(self, arg: UpdateRecipeParams) -> models.Recipe | None:
        row = (
            await self._conn.execute(
                sqlalchemy.text(UPDATE_RECIPE),
                {
                    "p1": arg.name,
                    "p2": arg.author,
                    "p3": arg.cuisine,
                    "p4": arg.location,
                    "p5": arg.time_estimate_minutes,
                    "p6": arg.notes,
                    "p7": arg.meal,
                    "p8": arg.type,
                    "p9": arg.recipeid,
                },
            )
        ).first()
        if row is None:
            return None
        return models.Recipe(
            id=row[0],
            user_id=row[1],
            name=row[2],
            author=row[3],
            cuisine=row[4],
            location=row[5],
            time_estimate_minutes=row[6],
            notes=row[7],
            last_made_at=row[8],
            created_at=row[9],
            updated_at=row[10],
            type=row[11],
            meal=row[12],
            parent_recipe_id=row[13],
        )
