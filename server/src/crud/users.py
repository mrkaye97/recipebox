# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.28.0
# source: users.sql
import datetime
import uuid
from collections.abc import AsyncIterator

import pydantic
import sqlalchemy
import sqlalchemy.ext.asyncio

from src.crud import models

AUTHENTICATE_USER = """-- name: authenticate_user \\:one
SELECT u.id, u.email, u.name, u.created_at, u.updated_at
FROM "user" u
JOIN user_password up ON u.id = up.user_id
WHERE
    (u.email = :p1\\:\\:TEXT OR u.id = :p2\\:\\:UUID)
    AND up.password_hash = :p3\\:\\:TEXT
"""


CREATE_USER = """-- name: create_user \\:one
INSERT INTO "user" (
    email,
    name
)
VALUES (
    :p1\\:\\:TEXT,
    :p2\\:\\:TEXT
)
RETURNING id, email, name, created_at, updated_at
"""


CREATE_USER_PASSWORD = """-- name: create_user_password \\:exec
INSERT INTO user_password (
    user_id,
    password_hash
)
VALUES (
    :p1\\:\\:UUID,
    :p2\\:\\:TEXT
)
"""


FIND_USER_BY_ID = """-- name: find_user_by_id \\:one
SELECT id, email, name, created_at, updated_at
FROM "user"
WHERE id = :p1
"""


SEARCH_USERS = """-- name: search_users \\:many
SELECT
    id, email, name, created_at, updated_at,
    similarity(name || ' ' || email, :p1\\:\\:TEXT) as relevance_score
FROM "user"
WHERE (name || ' ' || email) ILIKE '%' || :p1\\:\\:TEXT || '%'
ORDER BY relevance_score DESC, name ASC
LIMIT COALESCE(:p3\\:\\:INT, 25)
OFFSET COALESCE(:p2\\:\\:INT, 0)
"""


class SearchUsersRow(pydantic.BaseModel):
    id: uuid.UUID
    email: str
    name: str
    created_at: datetime.datetime
    updated_at: datetime.datetime
    relevance_score: float


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def authenticate_user(
        self, *, email: str | None, user_id: uuid.UUID | None, passwordhash: str
    ) -> models.User | None:
        row = (
            await self._conn.execute(
                sqlalchemy.text(AUTHENTICATE_USER),
                {"p1": email, "p2": user_id, "p3": passwordhash},
            )
        ).first()
        if row is None:
            return None
        return models.User(
            id=row[0],
            email=row[1],
            name=row[2],
            created_at=row[3],
            updated_at=row[4],
        )

    async def create_user(self, *, email: str, name: str) -> models.User | None:
        row = (
            await self._conn.execute(
                sqlalchemy.text(CREATE_USER), {"p1": email, "p2": name}
            )
        ).first()
        if row is None:
            return None
        return models.User(
            id=row[0],
            email=row[1],
            name=row[2],
            created_at=row[3],
            updated_at=row[4],
        )

    async def create_user_password(
        self, *, userid: uuid.UUID, passwordhash: str
    ) -> None:
        await self._conn.execute(
            sqlalchemy.text(CREATE_USER_PASSWORD), {"p1": userid, "p2": passwordhash}
        )

    async def find_user_by_id(self, *, userid: uuid.UUID) -> models.User | None:
        row = (
            await self._conn.execute(sqlalchemy.text(FIND_USER_BY_ID), {"p1": userid})
        ).first()
        if row is None:
            return None
        return models.User(
            id=row[0],
            email=row[1],
            name=row[2],
            created_at=row[3],
            updated_at=row[4],
        )

    async def search_users(
        self, *, query: str, useroffset: int, userlimit: int
    ) -> AsyncIterator[SearchUsersRow]:
        result = await self._conn.stream(
            sqlalchemy.text(SEARCH_USERS),
            {"p1": query, "p2": useroffset, "p3": userlimit},
        )
        async for row in result:
            yield SearchUsersRow(
                id=row[0],
                email=row[1],
                name=row[2],
                created_at=row[3],
                updated_at=row[4],
                relevance_score=row[5],
            )
