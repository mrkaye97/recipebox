# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.28.0
# source: query.sql
import datetime
import uuid
from collections.abc import AsyncIterator
from typing import Any

import pydantic
import sqlalchemy
import sqlalchemy.ext.asyncio

from src.crud import models

AUTHENTICATE_USER = """-- name: authenticate_user \\:one
SELECT u.id, u.email, u.name, u.created_at, u.updated_at
FROM "user" u
JOIN user_password up ON u.id = up.user_id
WHERE
    (u.email = :p1\\:\\:TEXT OR u.id = :p2\\:\\:UUID)
    AND up.password_hash = :p3\\:\\:TEXT
"""


CREATE_RECIPE = """-- name: create_recipe \\:one
INSERT INTO recipe (
    user_id,
    name,
    author,
    cuisine,
    location,
    time_estimate_minutes,
    notes
)
VALUES (
    :p1\\:\\:UUID,
    :p2\\:\\:TEXT,
    :p3\\:\\:TEXT,
    :p4\\:\\:TEXT,
    :p5\\:\\:JSONB,
    :p6\\:\\:INTEGER,
    :p7\\:\\:TEXT
)
RETURNING id, user_id, name, author, cuisine, location, time_estimate_minutes, notes, last_made_at, created_at, updated_at
"""


class CreateRecipeParams(pydantic.BaseModel):
    userid: uuid.UUID
    name: str
    author: str
    cuisine: str
    location: Any
    timeestimateminutes: int
    notes: str | None


CREATE_RECIPE_DIETARY_RESTRICTIONS_MET = """-- name: create_recipe_dietary_restrictions_met \\:many
WITH restrictions AS (
    SELECT UNNEST(:p3\\:\\:dietary_restriction[]) AS dietary_restriction
)

INSERT INTO recipe_dietary_restriction_met (recipe_id, user_id, dietary_restriction)
SELECT
    :p1\\:\\:UUID,
    :p2\\:\\:UUID,
    dietary_restriction
FROM restrictions
ON CONFLICT DO NOTHING
RETURNING user_id, recipe_id, dietary_restriction
"""


CREATE_RECIPE_INGREDIENTS = """-- name: create_recipe_ingredients \\:many
WITH ingredients AS (
    SELECT
        UNNEST(:p3\\:\\:TEXT[]) AS name,
        UNNEST(:p4\\:\\:FLOAT8[]) AS quantity,
        UNNEST(:p5\\:\\:TEXT[]) AS units
)

INSERT INTO recipe_ingredient (recipe_id, user_id, name, quantity, units)
SELECT
    :p1\\:\\:UUID,
    :p2\\:\\:UUID,
    name,
    quantity,
    units
FROM ingredients
ON CONFLICT DO NOTHING
RETURNING recipe_id, user_id, name, quantity, units, created_at, updated_at
"""


class CreateRecipeIngredientsParams(pydantic.BaseModel):
    recipeid: uuid.UUID
    userid: uuid.UUID
    names: list[str]
    quantities: list[float]
    units: list[str]


CREATE_RECIPE_INSTRUCTIONS = """-- name: create_recipe_instructions \\:many
WITH instructions AS (
    SELECT
        UNNEST(:p3\\:\\:INT[]) AS step_number,
        UNNEST(:p4\\:\\:TEXT[]) AS content
)

INSERT INTO recipe_instruction (recipe_id, user_id, step_number, content)
SELECT
    :p1\\:\\:UUID,
    :p2\\:\\:UUID,
    step_number,
    content
FROM instructions
ON CONFLICT DO NOTHING
RETURNING recipe_id, user_id, step_number, content, created_at, updated_at
"""


CREATE_RECIPE_TAGS = """-- name: create_recipe_tags \\:many
WITH tags AS (
    SELECT UNNEST(:p3\\:\\:TEXT[]) AS tag
)

INSERT INTO recipe_tag (recipe_id, user_id, tag)
SELECT
    :p1\\:\\:UUID,
    :p2\\:\\:UUID,
    tag
FROM tags
ON CONFLICT DO NOTHING
RETURNING user_id, recipe_id, tag
"""


CREATE_USER = """-- name: create_user \\:one
INSERT INTO "user" (
    email,
    name
)
VALUES (
    :p1\\:\\:TEXT,
    :p2\\:\\:TEXT
)
RETURNING id, email, name, created_at, updated_at
"""


CREATE_USER_PASSWORD = """-- name: create_user_password \\:exec
INSERT INTO user_password (
    user_id,
    password_hash
)
VALUES (
    :p1\\:\\:UUID,
    :p2\\:\\:TEXT
)
"""


DELETE_RECIPE = """-- name: delete_recipe \\:exec
DELETE FROM recipe
WHERE
    id = :p1\\:\\:UUID
    AND user_id = :p2\\:\\:UUID
RETURNING id, user_id, name, author, cuisine, location, time_estimate_minutes, notes, last_made_at, created_at, updated_at
"""


FIND_USER_BY_ID = """-- name: find_user_by_id \\:one
SELECT id, email, name, created_at, updated_at
FROM "user"
WHERE id = :p1
"""


GET_RECIPE = """-- name: get_recipe \\:one
SELECT id, user_id, name, author, cuisine, location, time_estimate_minutes, notes, last_made_at, created_at, updated_at
FROM recipe
WHERE id = :p1\\:\\:UUID
AND user_id = :p2\\:\\:UUID
"""


LIST_RECIPE_DIETARY_RESTRICTIONS_MET = """-- name: list_recipe_dietary_restrictions_met \\:many
SELECT user_id, recipe_id, dietary_restriction
FROM recipe_dietary_restriction_met
WHERE
    recipe_id = ANY(:p1\\:\\:UUID[])
    AND user_id = :p2\\:\\:UUID
"""


LIST_RECIPE_INGREDIENTS = """-- name: list_recipe_ingredients \\:many
SELECT recipe_id, user_id, name, quantity, units, created_at, updated_at
FROM recipe_ingredient
WHERE
    recipe_id = ANY(:p1\\:\\:UUID[])
    AND user_id = :p2\\:\\:UUID
"""


LIST_RECIPE_INSTRUCTIONS = """-- name: list_recipe_instructions \\:many
SELECT recipe_id, user_id, step_number, content, created_at, updated_at
FROM recipe_instruction
WHERE
    recipe_id = ANY(:p1\\:\\:UUID[])
    AND user_id = :p2\\:\\:UUID
ORDER BY step_number ASC
"""


LIST_RECIPE_TAGS = """-- name: list_recipe_tags \\:many
SELECT user_id, recipe_id, tag
FROM recipe_tag
WHERE
    recipe_id = ANY(:p1\\:\\:UUID[])
    AND user_id = :p2\\:\\:UUID
"""


LIST_RECIPES = """-- name: list_recipes \\:many
SELECT id, user_id, name, author, cuisine, location, time_estimate_minutes, notes, last_made_at, created_at, updated_at
FROM recipe
WHERE user_id = :p1\\:\\:UUID
ORDER BY updated_at DESC
"""


UPDATE_RECIPE = """-- name: update_recipe \\:one
UPDATE recipe
SET
    name = COALESCE(:p1\\:\\:TEXT, name),
    author = COALESCE(:p2\\:\\:TEXT, author),
    cuisine = COALESCE(:p3\\:\\:TEXT, cuisine),
    location = COALESCE(:p4\\:\\:JSONB, location),
    time_estimate_minutes = COALESCE(:p5\\:\\:INT, time_estimate_minutes),
    notes = COALESCE(:p6\\:\\:TEXT, notes),
    last_made_at = COALESCE(:p7\\:\\:TIMESTAMPTZ, last_made_at),
    updated_at = CURRENT_TIMESTAMP
WHERE
    id = :p8\\:\\:UUID
    AND user_id = :p9\\:\\:UUID
RETURNING id, user_id, name, author, cuisine, location, time_estimate_minutes, notes, last_made_at, created_at, updated_at
"""


class UpdateRecipeParams(pydantic.BaseModel):
    name: str | None
    author: str | None
    cuisine: str | None
    location: Any | None
    time_estimate_minutes: int | None
    notes: str | None
    last_made_at: datetime.datetime | None
    recipeid: uuid.UUID
    userid: uuid.UUID


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def authenticate_user(
        self, *, email: str | None, user_id: uuid.UUID | None, passwordhash: str
    ) -> models.User | None:
        row = (
            await self._conn.execute(
                sqlalchemy.text(AUTHENTICATE_USER),
                {"p1": email, "p2": user_id, "p3": passwordhash},
            )
        ).first()
        if row is None:
            return None
        return models.User(
            id=row[0],
            email=row[1],
            name=row[2],
            created_at=row[3],
            updated_at=row[4],
        )

    async def create_recipe(self, arg: CreateRecipeParams) -> models.Recipe | None:
        row = (
            await self._conn.execute(
                sqlalchemy.text(CREATE_RECIPE),
                {
                    "p1": arg.userid,
                    "p2": arg.name,
                    "p3": arg.author,
                    "p4": arg.cuisine,
                    "p5": arg.location,
                    "p6": arg.timeestimateminutes,
                    "p7": arg.notes,
                },
            )
        ).first()
        if row is None:
            return None
        return models.Recipe(
            id=row[0],
            user_id=row[1],
            name=row[2],
            author=row[3],
            cuisine=row[4],
            location=row[5],
            time_estimate_minutes=row[6],
            notes=row[7],
            last_made_at=row[8],
            created_at=row[9],
            updated_at=row[10],
        )

    async def create_recipe_dietary_restrictions_met(
        self,
        *,
        recipeid: uuid.UUID,
        userid: uuid.UUID,
        dietaryrestrictionsmets: list[models.DietaryRestriction],
    ) -> AsyncIterator[models.RecipeDietaryRestrictionMet]:
        result = await self._conn.stream(
            sqlalchemy.text(CREATE_RECIPE_DIETARY_RESTRICTIONS_MET),
            {"p1": recipeid, "p2": userid, "p3": dietaryrestrictionsmets},
        )
        async for row in result:
            yield models.RecipeDietaryRestrictionMet(
                user_id=row[0],
                recipe_id=row[1],
                dietary_restriction=row[2],
            )

    async def create_recipe_ingredients(
        self, arg: CreateRecipeIngredientsParams
    ) -> AsyncIterator[models.RecipeIngredient]:
        result = await self._conn.stream(
            sqlalchemy.text(CREATE_RECIPE_INGREDIENTS),
            {
                "p1": arg.recipeid,
                "p2": arg.userid,
                "p3": arg.names,
                "p4": arg.quantities,
                "p5": arg.units,
            },
        )
        async for row in result:
            yield models.RecipeIngredient(
                recipe_id=row[0],
                user_id=row[1],
                name=row[2],
                quantity=row[3],
                units=row[4],
                created_at=row[5],
                updated_at=row[6],
            )

    async def create_recipe_instructions(
        self,
        *,
        recipeid: uuid.UUID,
        userid: uuid.UUID,
        stepnumbers: list[int],
        contents: list[str],
    ) -> AsyncIterator[models.RecipeInstruction]:
        result = await self._conn.stream(
            sqlalchemy.text(CREATE_RECIPE_INSTRUCTIONS),
            {
                "p1": recipeid,
                "p2": userid,
                "p3": stepnumbers,
                "p4": contents,
            },
        )
        async for row in result:
            yield models.RecipeInstruction(
                recipe_id=row[0],
                user_id=row[1],
                step_number=row[2],
                content=row[3],
                created_at=row[4],
                updated_at=row[5],
            )

    async def create_recipe_tags(
        self, *, recipeid: uuid.UUID, userid: uuid.UUID, tags: list[str]
    ) -> AsyncIterator[models.RecipeTag]:
        result = await self._conn.stream(
            sqlalchemy.text(CREATE_RECIPE_TAGS),
            {"p1": recipeid, "p2": userid, "p3": tags},
        )
        async for row in result:
            yield models.RecipeTag(
                user_id=row[0],
                recipe_id=row[1],
                tag=row[2],
            )

    async def create_user(self, *, email: str, name: str) -> models.User | None:
        row = (
            await self._conn.execute(
                sqlalchemy.text(CREATE_USER), {"p1": email, "p2": name}
            )
        ).first()
        if row is None:
            return None
        return models.User(
            id=row[0],
            email=row[1],
            name=row[2],
            created_at=row[3],
            updated_at=row[4],
        )

    async def create_user_password(
        self, *, userid: uuid.UUID, passwordhash: str
    ) -> None:
        await self._conn.execute(
            sqlalchemy.text(CREATE_USER_PASSWORD), {"p1": userid, "p2": passwordhash}
        )

    async def delete_recipe(self, *, recipeid: uuid.UUID, userid: uuid.UUID) -> None:
        await self._conn.execute(
            sqlalchemy.text(DELETE_RECIPE), {"p1": recipeid, "p2": userid}
        )

    async def find_user_by_id(self, *, userid: uuid.UUID) -> models.User | None:
        row = (
            await self._conn.execute(sqlalchemy.text(FIND_USER_BY_ID), {"p1": userid})
        ).first()
        if row is None:
            return None
        return models.User(
            id=row[0],
            email=row[1],
            name=row[2],
            created_at=row[3],
            updated_at=row[4],
        )

    async def get_recipe(
        self, *, recipeid: uuid.UUID, userid: uuid.UUID
    ) -> models.Recipe | None:
        row = (
            await self._conn.execute(
                sqlalchemy.text(GET_RECIPE), {"p1": recipeid, "p2": userid}
            )
        ).first()
        if row is None:
            return None
        return models.Recipe(
            id=row[0],
            user_id=row[1],
            name=row[2],
            author=row[3],
            cuisine=row[4],
            location=row[5],
            time_estimate_minutes=row[6],
            notes=row[7],
            last_made_at=row[8],
            created_at=row[9],
            updated_at=row[10],
        )

    async def list_recipe_dietary_restrictions_met(
        self, *, recipeids: list[uuid.UUID], userid: uuid.UUID
    ) -> AsyncIterator[models.RecipeDietaryRestrictionMet]:
        result = await self._conn.stream(
            sqlalchemy.text(LIST_RECIPE_DIETARY_RESTRICTIONS_MET),
            {"p1": recipeids, "p2": userid},
        )
        async for row in result:
            yield models.RecipeDietaryRestrictionMet(
                user_id=row[0],
                recipe_id=row[1],
                dietary_restriction=row[2],
            )

    async def list_recipe_ingredients(
        self, *, recipeids: list[uuid.UUID], userid: uuid.UUID
    ) -> AsyncIterator[models.RecipeIngredient]:
        result = await self._conn.stream(
            sqlalchemy.text(LIST_RECIPE_INGREDIENTS), {"p1": recipeids, "p2": userid}
        )
        async for row in result:
            yield models.RecipeIngredient(
                recipe_id=row[0],
                user_id=row[1],
                name=row[2],
                quantity=row[3],
                units=row[4],
                created_at=row[5],
                updated_at=row[6],
            )

    async def list_recipe_instructions(
        self, *, recipeids: list[uuid.UUID], userid: uuid.UUID
    ) -> AsyncIterator[models.RecipeInstruction]:
        result = await self._conn.stream(
            sqlalchemy.text(LIST_RECIPE_INSTRUCTIONS), {"p1": recipeids, "p2": userid}
        )
        async for row in result:
            yield models.RecipeInstruction(
                recipe_id=row[0],
                user_id=row[1],
                step_number=row[2],
                content=row[3],
                created_at=row[4],
                updated_at=row[5],
            )

    async def list_recipe_tags(
        self, *, recipeids: list[uuid.UUID], userid: uuid.UUID
    ) -> AsyncIterator[models.RecipeTag]:
        result = await self._conn.stream(
            sqlalchemy.text(LIST_RECIPE_TAGS), {"p1": recipeids, "p2": userid}
        )
        async for row in result:
            yield models.RecipeTag(
                user_id=row[0],
                recipe_id=row[1],
                tag=row[2],
            )

    async def list_recipes(self, *, userid: uuid.UUID) -> AsyncIterator[models.Recipe]:
        result = await self._conn.stream(sqlalchemy.text(LIST_RECIPES), {"p1": userid})
        async for row in result:
            yield models.Recipe(
                id=row[0],
                user_id=row[1],
                name=row[2],
                author=row[3],
                cuisine=row[4],
                location=row[5],
                time_estimate_minutes=row[6],
                notes=row[7],
                last_made_at=row[8],
                created_at=row[9],
                updated_at=row[10],
            )

    async def update_recipe(self, arg: UpdateRecipeParams) -> models.Recipe | None:
        row = (
            await self._conn.execute(
                sqlalchemy.text(UPDATE_RECIPE),
                {
                    "p1": arg.name,
                    "p2": arg.author,
                    "p3": arg.cuisine,
                    "p4": arg.location,
                    "p5": arg.time_estimate_minutes,
                    "p6": arg.notes,
                    "p7": arg.last_made_at,
                    "p8": arg.recipeid,
                    "p9": arg.userid,
                },
            )
        ).first()
        if row is None:
            return None
        return models.Recipe(
            id=row[0],
            user_id=row[1],
            name=row[2],
            author=row[3],
            cuisine=row[4],
            location=row[5],
            time_estimate_minutes=row[6],
            notes=row[7],
            last_made_at=row[8],
            created_at=row[9],
            updated_at=row[10],
        )
