# Code generated by sqlc. DO NOT EDIT.
# versions:
#   sqlc v1.28.0
# source: query.sql
import datetime
import pydantic
from typing import Any, AsyncIterator, List, Optional
import uuid

import sqlalchemy
import sqlalchemy.ext.asyncio

from src.crud import models


CREATE_RECIPE = """-- name: create_recipe \\:one
INSERT INTO recipe (
    name,
    author,
    cuisine,
    location,
    time_estimate_minutes,
    notes
)
VALUES (
    :p1,
    :p2,
    :p3,
    :p4,
    :p5,
    :p6
)
RETURNING id, user_id, name, author, cuisine, location, time_estimate_minutes, notes, last_made_at, created_at, updated_at
"""


class CreateRecipeParams(pydantic.BaseModel):
    name: str
    author: str
    cuisine: str
    location: Any
    timeestimateminutes: int
    notes: Optional[str]


CREATE_RECIPE_DIETARY_RESTRICTIONS_MET = """-- name: create_recipe_dietary_restrictions_met \\:many
WITH restrictions AS (
    SELECT
        UNNEST(:p1\\:\\:UUID[]) AS recipe_id,
        UNNEST(:p2\\:\\:dietary_restriction[]) AS dietary_restriction_met
)

INSERT INTO recipe_dietary_restriction_met (recipe_id, dietary_restriction_met)
SELECT
    recipe_id,
    dietary_restriction_met
FROM restrictions
ON CONFLICT DO NOTHING
RETURNING recipe_id, dietary_restriction
"""


CREATE_RECIPE_INGREDIENTS = """-- name: create_recipe_ingredients \\:many
WITH ingredients AS (
    SELECT
        UNNEST(:p1\\:\\:UUID[]) AS recipe_id,
        UNNEST(:p2\\:\\:TEXT[]) AS name,
        UNNEST(:p3\\:\\:FLOAT8[]) AS quantity,
        UNNEST(:p4\\:\\:TEXT[]) AS units
)

INSERT INTO recipe_ingredient (recipe_id, name, quantity, units)
SELECT
    recipe_id,
    name,
    quantity,
    units
FROM ingredients
ON CONFLICT DO NOTHING
RETURNING recipe_id, name, quantity, units, created_at, updated_at
"""


CREATE_RECIPE_INSTRUCTIONS = """-- name: create_recipe_instructions \\:many
WITH instructions AS (
    SELECT
        UNNEST(:p1\\:\\:UUID[]) AS recipe_id,
        UNNEST(:p2\\:\\:INT[]) AS step_number,
        UNNEST(:p3\\:\\:TEXT[]) AS instruction
)

INSERT INTO recipe_instruction (recipe_id, step_number, instruction)
SELECT
    recipe_id,
    step_number,
    instruction
FROM instructions
ON CONFLICT DO NOTHING
RETURNING recipe_id, step_number, content, created_at, updated_at
"""


CREATE_RECIPE_TAGS = """-- name: create_recipe_tags \\:many
WITH tags AS (
    SELECT
        UNNEST(:p1\\:\\:UUID[]) AS recipe_id,
        UNNEST(:p2\\:\\:TEXT[]) AS tag
)

INSERT INTO recipe_tag (recipe_id, tag)
SELECT
    recipe_id,
    tag
FROM tags
ON CONFLICT DO NOTHING
RETURNING recipe_id, tag
"""


DELETE_RECIPE = """-- name: delete_recipe \\:one
DELETE FROM recipe
WHERE id = :p1\\:\\:UUID
AND user_id = :p2\\:\\:UUID
RETURNING id, user_id, name, author, cuisine, location, time_estimate_minutes, notes, last_made_at, created_at, updated_at
"""


FIND_USER_BY_ID = """-- name: find_user_by_id \\:one
SELECT id, username, email, name, created_at, updated_at
FROM "user"
WHERE id = :p1
"""


GET_RECIPE = """-- name: get_recipe \\:one
SELECT id, user_id, name, author, cuisine, location, time_estimate_minutes, notes, last_made_at, created_at, updated_at
FROM recipe
WHERE id = :p1\\:\\:UUID
AND user_id = :p2\\:\\:UUID
"""


LIST_RECIPES = """-- name: list_recipes \\:many
SELECT id, user_id, name, author, cuisine, location, time_estimate_minutes, notes, last_made_at, created_at, updated_at
FROM recipe
WHERE user_id = :p1\\:\\:UUID
ORDER BY updated_at DESC
"""


UPDATE_RECIPE = """-- name: update_recipe \\:one
UPDATE recipe
SET
    name = COALESCE(:p1\\:\\:TEXT, name),
    author = COALESCE(:p2\\:\\:TEXT, author),
    cuisine = COALESCE(:p3\\:\\:TEXT, cuisine),
    location = COALESCE(:p4\\:\\:JSONB, location),
    time_estimate_minutes = COALESCE(:p5\\:\\:INT, time_estimate_minutes),
    notes = COALESCE(:p6\\:\\:TEXT, notes),
    last_made_at = COALESCE(:p7\\:\\:TIMESTAMPTZ, last_made_at),
    updated_at = CURRENT_TIMESTAMP
WHERE id = :p8\\:\\:UUID
AND user_id = :p9\\:\\:UUID
RETURNING id, user_id, name, author, cuisine, location, time_estimate_minutes, notes, last_made_at, created_at, updated_at
"""


class UpdateRecipeParams(pydantic.BaseModel):
    name: str
    author: str
    cuisine: str
    location: Any
    timeestimateminutes: int
    notes: str
    lastmadeat: datetime.datetime
    recipeid: uuid.UUID
    userid: uuid.UUID


class AsyncQuerier:
    def __init__(self, conn: sqlalchemy.ext.asyncio.AsyncConnection):
        self._conn = conn

    async def create_recipe(self, arg: CreateRecipeParams) -> Optional[models.Recipe]:
        row = (await self._conn.execute(sqlalchemy.text(CREATE_RECIPE), {
            "p1": arg.name,
            "p2": arg.author,
            "p3": arg.cuisine,
            "p4": arg.location,
            "p5": arg.timeestimateminutes,
            "p6": arg.notes,
        })).first()
        if row is None:
            return None
        return models.Recipe(
            id=row[0],
            user_id=row[1],
            name=row[2],
            author=row[3],
            cuisine=row[4],
            location=row[5],
            time_estimate_minutes=row[6],
            notes=row[7],
            last_made_at=row[8],
            created_at=row[9],
            updated_at=row[10],
        )

    async def create_recipe_dietary_restrictions_met(self, *, recipeid: List[uuid.UUID], dietaryrestrictionmet: List[models.DietaryRestriction]) -> AsyncIterator[models.RecipeDietaryRestrictionMet]:
        result = await self._conn.stream(sqlalchemy.text(CREATE_RECIPE_DIETARY_RESTRICTIONS_MET), {"p1": recipeid, "p2": dietaryrestrictionmet})
        async for row in result:
            yield models.RecipeDietaryRestrictionMet(
                recipe_id=row[0],
                dietary_restriction=row[1],
            )

    async def create_recipe_ingredients(self, *, recipeid: List[uuid.UUID], name: List[str], quantity: List[float], units: List[str]) -> AsyncIterator[models.RecipeIngredient]:
        result = await self._conn.stream(sqlalchemy.text(CREATE_RECIPE_INGREDIENTS), {
            "p1": recipeid,
            "p2": name,
            "p3": quantity,
            "p4": units,
        })
        async for row in result:
            yield models.RecipeIngredient(
                recipe_id=row[0],
                name=row[1],
                quantity=row[2],
                units=row[3],
                created_at=row[4],
                updated_at=row[5],
            )

    async def create_recipe_instructions(self, *, recipeid: List[uuid.UUID], stepnumber: List[int], instruction: List[str]) -> AsyncIterator[models.RecipeInstruction]:
        result = await self._conn.stream(sqlalchemy.text(CREATE_RECIPE_INSTRUCTIONS), {"p1": recipeid, "p2": stepnumber, "p3": instruction})
        async for row in result:
            yield models.RecipeInstruction(
                recipe_id=row[0],
                step_number=row[1],
                content=row[2],
                created_at=row[3],
                updated_at=row[4],
            )

    async def create_recipe_tags(self, *, recipeid: List[uuid.UUID], tag: List[str]) -> AsyncIterator[models.RecipeTag]:
        result = await self._conn.stream(sqlalchemy.text(CREATE_RECIPE_TAGS), {"p1": recipeid, "p2": tag})
        async for row in result:
            yield models.RecipeTag(
                recipe_id=row[0],
                tag=row[1],
            )

    async def delete_recipe(self, *, recipeid: uuid.UUID, userid: uuid.UUID) -> Optional[models.Recipe]:
        row = (await self._conn.execute(sqlalchemy.text(DELETE_RECIPE), {"p1": recipeid, "p2": userid})).first()
        if row is None:
            return None
        return models.Recipe(
            id=row[0],
            user_id=row[1],
            name=row[2],
            author=row[3],
            cuisine=row[4],
            location=row[5],
            time_estimate_minutes=row[6],
            notes=row[7],
            last_made_at=row[8],
            created_at=row[9],
            updated_at=row[10],
        )

    async def find_user_by_id(self, *, userid: uuid.UUID) -> Optional[models.User]:
        row = (await self._conn.execute(sqlalchemy.text(FIND_USER_BY_ID), {"p1": userid})).first()
        if row is None:
            return None
        return models.User(
            id=row[0],
            username=row[1],
            email=row[2],
            name=row[3],
            created_at=row[4],
            updated_at=row[5],
        )

    async def get_recipe(self, *, recipeid: uuid.UUID, userid: uuid.UUID) -> Optional[models.Recipe]:
        row = (await self._conn.execute(sqlalchemy.text(GET_RECIPE), {"p1": recipeid, "p2": userid})).first()
        if row is None:
            return None
        return models.Recipe(
            id=row[0],
            user_id=row[1],
            name=row[2],
            author=row[3],
            cuisine=row[4],
            location=row[5],
            time_estimate_minutes=row[6],
            notes=row[7],
            last_made_at=row[8],
            created_at=row[9],
            updated_at=row[10],
        )

    async def list_recipes(self, *, userid: uuid.UUID) -> AsyncIterator[models.Recipe]:
        result = await self._conn.stream(sqlalchemy.text(LIST_RECIPES), {"p1": userid})
        async for row in result:
            yield models.Recipe(
                id=row[0],
                user_id=row[1],
                name=row[2],
                author=row[3],
                cuisine=row[4],
                location=row[5],
                time_estimate_minutes=row[6],
                notes=row[7],
                last_made_at=row[8],
                created_at=row[9],
                updated_at=row[10],
            )

    async def update_recipe(self, arg: UpdateRecipeParams) -> Optional[models.Recipe]:
        row = (await self._conn.execute(sqlalchemy.text(UPDATE_RECIPE), {
            "p1": arg.name,
            "p2": arg.author,
            "p3": arg.cuisine,
            "p4": arg.location,
            "p5": arg.timeestimateminutes,
            "p6": arg.notes,
            "p7": arg.lastmadeat,
            "p8": arg.recipeid,
            "p9": arg.userid,
        })).first()
        if row is None:
            return None
        return models.Recipe(
            id=row[0],
            user_id=row[1],
            name=row[2],
            author=row[3],
            cuisine=row[4],
            location=row[5],
            time_estimate_minutes=row[6],
            notes=row[7],
            last_made_at=row[8],
            created_at=row[9],
            updated_at=row[10],
        )
